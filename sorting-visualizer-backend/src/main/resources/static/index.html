<!DOCTYPE html>
<html>
<head>
  <title>Sorting Visualizer</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="header">Sorting Visualizer</div>
  <div id="controls">
    <input id="array-input" placeholder="Enter numbers, e.g. 5,2,9,1" />
    <button id="generate-btn" onclick="generateArray()">Random Array</button>
    <select id="algorithm-select">
      <option value="bubble">Bubble Sort</option>
      <option value="selection">Selection Sort</option>
      <option value="insertion">Insertion Sort</option>
      <option value="merge">Merge Sort</option>
      <option value="quick">Quick Sort</option>
    </select>
    <button id="sort-btn" onclick="startSort()">Sort</button>
  </div>
  <div id="array-container"></div>
  <div id="visualizer"></div>
  <script>
    let array = [];
    const arrayContainer = document.getElementById('array-container');

    function renderArray(arr, activeIndices = [], sortedIndices = []) {
      arrayContainer.innerHTML = '';
      arr.forEach((value, idx) => {
        const bar = document.createElement('div');
        bar.classList.add('bar');
        bar.style.height = (value * 2.5) + 'px';
        bar.setAttribute('data-value', value);
        if (activeIndices.includes(idx)) bar.classList.add('active');
        if (sortedIndices.includes(idx)) bar.classList.add('sorted');
        arrayContainer.appendChild(bar);
      });
    }

    function generateArray() {
      const input = document.getElementById('array-input').value;
      if (input.trim()) {
        array = input.split(',').map(x => parseInt(x.trim())).filter(x => !isNaN(x));
      } else {
        array = Array.from({length: 20}, () => Math.floor(Math.random() * 100) + 10);
      }
      renderArray(array);
    }

    async function bubbleSort(arr) {
      let sortedIndices = [];
      for (let i = 0; i < arr.length; i++) {
        for (let j = 0; j < arr.length - i - 1; j++) {
          renderArray(arr, [j, j+1], sortedIndices);
          await sleep(100);
          if (arr[j] > arr[j+1]) {
            [arr[j], arr[j+1]] = [arr[j+1], arr[j]];
          }
        }
        sortedIndices.push(arr.length - i - 1);
      }
      renderArray(arr, [], sortedIndices);
    }

    async function selectionSort(arr) {
      let sortedIndices = [];
      for (let i = 0; i < arr.length; i++) {
        let minIdx = i;
        for (let j = i+1; j < arr.length; j++) {
          renderArray(arr, [minIdx, j], sortedIndices);
          await sleep(100);
          if (arr[j] < arr[minIdx]) minIdx = j;
        }
        [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
        sortedIndices.push(i);
      }
      renderArray(arr, [], sortedIndices);
    }

    async function insertionSort(arr) {
      let sortedIndices = [];
      for (let i = 1; i < arr.length; i++) {
        let key = arr[i];
        let j = i - 1;
        while (j >= 0 && arr[j] > key) {
          renderArray(arr, [j, i], sortedIndices);
          await sleep(100);
          arr[j + 1] = arr[j];
          j--;
        }
        arr[j + 1] = key;
        sortedIndices = Array.from({length: i+1}, (_, idx) => idx);
      }
      renderArray(arr, [], sortedIndices);
    }

    async function mergeSort(arr) {
      let sortedIndices = [];
      await mergeSortHelper(arr, 0, arr.length - 1, sortedIndices);
      renderArray(arr, [], Array.from({length: arr.length}, (_, i) => i));
    }

    async function mergeSortHelper(arr, left, right, sortedIndices) {
      if (left >= right) return;
      const mid = Math.floor((left + right) / 2);
      await mergeSortHelper(arr, left, mid, sortedIndices);
      await mergeSortHelper(arr, mid + 1, right, sortedIndices);
      await merge(arr, left, mid, right, sortedIndices);
    }

    async function merge(arr, left, mid, right, sortedIndices) {
      let n1 = mid - left + 1;
      let n2 = right - mid;
      let L = arr.slice(left, mid + 1);
      let R = arr.slice(mid + 1, right + 1);
      let i = 0, j = 0, k = left;
      while (i < n1 && j < n2) {
        renderArray(arr, [k], sortedIndices);
        await sleep(100);
        if (L[i] <= R[j]) {
          arr[k++] = L[i++];
        } else {
          arr[k++] = R[j++];
        }
      }
      while (i < n1) {
        renderArray(arr, [k], sortedIndices);
        await sleep(100);
        arr[k++] = L[i++];
      }
      while (j < n2) {
        renderArray(arr, [k], sortedIndices);
        await sleep(100);
        arr[k++] = R[j++];
      }
    }

    async function quickSort(arr) {
      let sortedIndices = [];
      await quickSortHelper(arr, 0, arr.length - 1, sortedIndices);
      renderArray(arr, [], Array.from({length: arr.length}, (_, i) => i));
    }

    async function quickSortHelper(arr, low, high, sortedIndices) {
      if (low < high) {
        let pi = await partition(arr, low, high, sortedIndices);
        await quickSortHelper(arr, low, pi - 1, sortedIndices);
        await quickSortHelper(arr, pi + 1, high, sortedIndices);
      }
    }

    async function partition(arr, low, high, sortedIndices) {
      let pivot = arr[high];
      let i = low - 1;
      for (let j = low; j < high; j++) {
        renderArray(arr, [j, high], sortedIndices);
        await sleep(100);
        if (arr[j] < pivot) {
          i++;
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
      }
      [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
      return i + 1;
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function startSort() {
      const algo = document.getElementById('algorithm-select').value;
      let arrCopy = array.slice();
      if (arrCopy.length === 0) return;
      if (algo === 'bubble') bubbleSort(arrCopy);
      else if (algo === 'selection') selectionSort(arrCopy);
      else if (algo === 'insertion') insertionSort(arrCopy);
      else if (algo === 'merge') mergeSort(arrCopy);
      else if (algo === 'quick') quickSort(arrCopy);
    }

    // Initial render
    generateArray();
  </script>
</body>
</html>
    }
  </script>
</body>
</html>
